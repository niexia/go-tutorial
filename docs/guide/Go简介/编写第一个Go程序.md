# 编写第一个 Go 程序

## 开发环境变量设置

Go 开发环境依赖于一些操作系统环境变量，你最好在安装 Go 之前就已经设置好他们。

- `$GOROOT` 表示 Go 在你的电脑上的安装位置，它的值一般都是 $HOME/go，当然，你也可以安装在别的地方。
- `$GOARCH` 表示目标机器的处理器架构，它的值可以是 386、amd64 或 arm。
- `$GOOS` 表示目标机器的操作系统，它的值可以是 darwin、freebsd、linux 或 windows。
- `$GOBIN` 
  表示编译器和链接器的安装位置，默认是 `$GOROOT/bin`，如果你使用的是 Go 1.0.3 及以后的版本，一般情况下你可以将它的值设置为空，Go 将会使用前面提到的默认值。目标机器是指你打算运行你的 Go 应用程序的机器。

  Go 编译器支持交叉编译，也就是说你可以在一台机器上构建运行在具有不同操作系统和处理器架构上运行的应用程序，也就是说编写源代码的机器可以和目标机器有完全不同的特性（操作系统与处理器架构）。

  为了区分本地机器和目标机器，你可以使用 `$GOHOSTOS` 和` $GOHOSTARCH` 设置本地机器的操作系统名称和编译体系结构，这两个变量只有在进行交叉编译的时候才会用到，如果你不进行显示设置，他们的值会和本地机器（`$GOOS` 和 `$GOARCH`）一样。

- `$GOPATH`
  默认采用和` $GOROOT` 一样的值，但从 Go 1.1 版本开始，你必须修改为其它路径。它可以包含多个 Go 语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：src、pkg 和 bin，这三个目录分别用于存放源码文件、包文件和可执行文件。

  在 Go 1.8 版本之前，`$GOPATH` 环境变量默认是空的。从 Go 1.8 版本开始，Go 开发包在安装完成后会为 `$GOPATH` 设置一个默认目录，

- `$GOARM` 专门针对基于 arm 架构的处理器，它的值可以是 5 或 6，默认为 6。
- `$GOMAXPROCS` 用于设置应用程序可使用的处理器个数与核数

## 应用程序的入口

1. 必须是 `main` 包： `package main`
2. 必须是 `main` 方法：`func main()`
3. 文件名不一定是 `main.go`

## 退出返回值

与其他程序的不同

- Go 中 `main` 不支持任何返回值
- 通过 `os.Exit` 来返回状态

```go
func main()  {
	fmt.Println("hello world")
	os.Exit(-1)
}
```

## 获取命令行参数

与其他语言的差异

- `main` 不支持传入参数

```go
func main(arg []string)
```

- 在程序中通过 `os.Args` 获取命令行参数

```go
package main

import "fmt"
import "os"

func main()  {
	fmt.Println(os.Args)
	if len(os.Args) > 1 {
		fmt.Println("hello world", os.Args[1])
	}
}
```

## 格式化代码

Go 开发团队不想要 Go 语言像许多其它语言那样总是在为代码风格而引发无休止的争论，浪费大量宝贵的开发时间，因此他们制作了一个工具：**go fmt（gofmt）**。

这个工具可以将你的源代码格式化成符合官方统一标准的风格，属于语法风格层面上的小型重构。遵循统一的代码风格是 Go 开发中无可撼动的铁律，因此你必须在编译或提交版本管理系统之前使用 `gofmt` 来格式化你的代码。

在命令行输入:

- `gofmt –w program.go` 会格式化该源文件的代码然后将格式化后的代码覆盖原始内容（如果不加参数 -w 则只会打印格式化后的结果而不重写文件）；
- `gofmt -w *.go` 会格式化并重写所有 Go 源文件；
- `gofmt map1` 会格式化并重写 map1 目录及其子目录下的所有 Go 源文件。

`gofmt` 也可以通过在参数 `-r` 后面加入用双引号括起来的替换规则实现代码的简单重构，规则的格式：**<原始内容> -> <替换内容>**。

```shell
# 将源文件中没有意义的括号去掉。
gofmt -r '(a) -> a' –w *.go

# 将源文件中多余的 len(a) 去掉
gofmt -r 'a[n:len(a)] -> a[n:]' –w *.go

# 将源文件中符合条件的函数的参数调换位置
gofmt –r 'A.Func1(a,b) -> A.Func2(b,a)' –w *.go
```