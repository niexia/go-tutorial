# è¡Œä¸ºçš„å®šä¹‰å’Œå®ç°

## Go æ˜¯å¦æ˜¯é¢å‘å¯¹è±¡çš„è¯­è¨€

> Yes and no. Although Go has types and methods and allows an object-oriented style of programming, there is no type hierarchy. The concept of â€œinterfaceâ€ in Go provides a different approach that we believe is easy to use and in some ways more general. There are also ways to embed types in other types to provide something analogousâ€”but not identicalâ€”to subclassing. Moreover, methods in Go are more general than in C++ or Java: they can be defined for any sort of data, even built-in types such as plain, â€œunboxedâ€ integers. They are not restricted to structs (classes).
Also, the lack of a type hierarchy makes â€œobjectsâ€ in Go feel much more lightweight than in languages such as C++ or Java.<br>
> æ˜¯,ä¹Ÿä¸æ˜¯.è™½ç„¶Goè¯­è¨€å¯ä»¥é€šè¿‡å®šä¹‰ç±»å‹å’Œæ–¹æ³•æ¥å®ç°é¢å‘å¯¹è±¡çš„è®¾è®¡é£æ ¼,ä½†æ˜¯Goæ˜¯å®é™…ä¸Šå¹¶æ²¡æœ‰ç»§æ‰¿è¿™ä¸€è¯´æ³•.åœ¨Goè¯­è¨€ä¸­,interface(æ¥å£)è¿™ä¸ªæ¦‚å¿µä»¥å¦å¤–ä¸€ç§è§’åº¦å±•ç°äº†ä¸€ç§æ›´åŠ æ˜“ç”¨ä¸é€šç”¨çš„è®¾è®¡æ–¹æ³•.åœ¨Goä¸­,æˆ‘ä»¬å¯ä»¥é€šè¿‡ç»„åˆ,ä¹Ÿå°±æ˜¯å°†æŸä¸ªç±»å‹æ”¾å…¥å¦å¤–çš„ä¸€ä¸ªç±»å‹ä¸­æ¥å®ç°ç±»ä¼¼ç»§æ‰¿,è®©è¯¥ç±»å‹æä¾›æœ‰å…±æ€§ä½†ä¸ç›¸åŒçš„åŠŸèƒ½.ç›¸æ¯”èµ·C++å’ŒJava,Goæä¾›äº†æ›´åŠ é€šç”¨çš„å®šä¹‰å‡½æ•°çš„æ–¹æ³•,æˆ‘ä»¬å¯ä»¥æŒ‡å®šå‡½æ•°çš„æ¥å—å¯¹è±¡(receiver),å®ƒå¯ä»¥æ˜¯ä»»æ„çš„ç±»å‹,åŒ…æ‹¬å†…å»ºç±»å‹,åœ¨è¿™é‡Œæ²¡æœ‰ä»»ä½•çš„é™åˆ¶.
åŒæ ·çš„,æ²¡æœ‰äº†ç±»å‹ç»§æ‰¿,ä½¿å¾—Goè¯­è¨€åœ¨é¢å‘å¯¹è±¡ç¼–ç¨‹çš„æ–¹é¢ä¼šæ˜¾å¾—æ›´åŠ è½»é‡åŒ–

## å°è£…æ•°æ®å’Œè¡Œä¸º

### ç»“æ„ä½“å®šä¹‰

```go
type Employee struct {
  Id    string
  Name  string
  Age   int
}
```

### å®ä¾‹åˆ›å»ºå’Œåˆå§‹åŒ–

```go
e := Employee{"0", "Bob", 20} // ä¸€ä¸€å¯¹åº”
e1 := Employee{Name: "Mike", Age: 30}

e2 := new(Employee) // æ³¨æ„è¿™é‡Œè¿”å›çš„æ˜¯æŒ‡é’ˆï¼Œç›¸å½“äº := &Employee{}
e2.Id = "2" // å’Œå…¶ä»–è¯­è¨€çš„å·®å¼‚ï¼šé€šè¿‡å®ä¾‹çš„æŒ‡é’ˆè®¿é—®æˆå‘˜ä¸éœ€è¦ä½¿ç”¨ ->
e2.Age = 22
e2.Name = "Rose"
```

çœ‹ä¸ªğŸŒ°

```go
package encaptest

import (
	"testing"
)

type Employee struct {
	Id   string
	Name string
	Age  int
}

func TestCreateEmployeeObj(t *testing.T) {
	e := Employee{"0", "Bob", 20}

	e1 := Employee{Name: "Mike", Age: 30}

	e2 := new(Employee) // è¿”å›æŒ‡é’ˆ
	e2.Id = "2"
	e2.Age = 22
	e2.Name = "Rose"

	t.Log(e) // {0 Bob 20}
	t.Log(e1) // { Mike 30}
	t.Log(e1.Id) //

	t.Log(e2) // &{2 Rose 22}
	t.Logf("e is %T", e) // e is encaptest.Employee
	t.Logf("e2 is %T", e2) // e2 is *encaptest.Employee
}
```

## è¡Œä¸ºï¼ˆæ–¹æ³•ï¼‰å®šä¹‰

å’Œå…¶ä»–ä¸»è¦ç¼–ç¨‹è¯­è¨€çš„å·®å¼‚

```go
type Employee struct {
	Id   string
	Name string
	Age  int
}

// ä¸‹é¢è¿™ç§å®šä¹‰æ–¹å¼ï¼Œå®šä¹‰äº†ä¸€ä¸ª Employee çš„ String æ–¹æ³•
// åœ¨å®ä¾‹çš„æ–¹æ³•è¢«è°ƒç”¨æ—¶ï¼Œå®ä¾‹çš„æˆå‘˜ä¼šè¿›è¡Œå€¼å¤åˆ¶
func (e Employee) String() string {
  return fmt.Sprintf("ID:%s-Name:%s-Age:%d", e.Id, e.Name, e.Age)
}

// é€šå¸¸æƒ…å†µä¸‹åº”è¯¥ä½¿ç”¨è¿™ç§å®šä¹‰æ–¹å¼ï¼Œé¿å…å†…å­˜æ‹·è´
// å®šä¹‰çš„æ˜¯ç±»å‹çš„æŒ‡é’ˆ
func (e *Employee) String() string {
  return fmt.Sprintf("ID:%s/Name:%s/Age:%d", e.Id, e.Name, e.Age)
}
```

çœ‹ä¸ªğŸŒ°

```go
// ç¬¬ 1 ç§
func (e Employee) String() string {
	return fmt.Sprintf("ID:%s-Name:%s-Age:%d", e.Id, e.Name, e.Age)
}

func TestStructOperations(t *testing.T) {
	e := Employee{"0", "Bob", 20}
	t.Log(e.String()) // ID:0-Name:Bob-Age:20
}

// ç¬¬ 2 ç§
func (e *Employee) String() string {
	return fmt.Sprintf("ID:%s/Name:%s/Age:%d", e.Id, e.Name, e.Age)
}

func TestStructOperations(t *testing.T) {
	e := Employee{"0", "Bob", 20}
	t.Log(e.String()) // ID:0/Name:Bob/Age:20
}

// å¯¹æ¯”
// ä½¿ç”¨ç¬¬äºŒç§æ–¹å¼è¾“å‡ºåœ°å€ä¸€è‡´ï¼Œæ²¡æœ‰å¯¹è±¡å¤åˆ¶äº§ç”Ÿ
func (e *Employee) String() string {
	// è°ƒç”¨æ—¶è¾“å‡º
	fmt.Printf("Address is %x", unsafe.Pointer(&e.Name))
	return fmt.Sprintf("ID:%s/Name:%s/Age:%d", e.Id, e.Name, e.Age)
}

func TestStructOperations(t *testing.T) {
	e := Employee{"0", "Bob", 20}
	// è°ƒç”¨å‰è¾“å‡º
	fmt.Printf("Address is %x\n", unsafe.Pointer(&e.Name))
	t.Log(e.String())
}
// Address is c0000a43a0
// Address is c0000a43a0

// ä½¿ç”¨ç¬¬ä¸€ç§æ–¹å¼åœ°å€å˜äº†ï¼Œäº§ç”Ÿå¤åˆ¶ï¼Œå¼€é”€æ›´å¤§ï¼ï¼ï¼
func (e Employee) String() string {
	fmt.Printf("Address is %x", unsafe.Pointer(&e.Name))
	return fmt.Sprintf("ID:%s-Name:%s-Age:%d", e.Id, e.Name, e.Age)
}
func TestStructOperations(t *testing.T) {
	e := Employee{"0", "Bob", 20}
	// è°ƒç”¨å‰è¾“å‡º
	fmt.Printf("Address is %x\n", unsafe.Pointer(&e.Name))
	t.Log(e.String())
}
// Address is c00009a3a0
// Address is c00009a3d0 åœ°å€å˜äº†
```